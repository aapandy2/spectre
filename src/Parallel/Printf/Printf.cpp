// Distributed under the MIT License.
// See LICENSE.txt for details.

#include "Parallel/Printf/Printf.hpp"

#include <cerrno>
#include <cstdio>
#include <memory>
#include <string>
#include <vector>

#include "Utilities/ErrorHandling/Error.hpp"
#include "Utilities/ErrorHandling/Strerror.hpp"
#include "Utilities/System/ParallelInfo.hpp"

namespace {
void do_print(const bool error, const std::vector<char>& message) {
  FILE* const stream = error ? stderr : stdout;
  // fprintf is atomic and threadsafe within a single process (via
  // locks).  See flockfile(3).

  // cert-err33-c: False positive: "The return value of a call to
  // fprintf() ... may be ignored if the output is being directed to
  // stdout or stderr."

  // cppcoreguidelines-pro-type-vararg: I cannot change the signature
  // of fprintf.

  // NOLINTNEXTLINE(cert-err33-c,cppcoreguidelines-pro-type-vararg)
  fprintf(stream, "%s", message.data());
}

void do_print_to_file(const std::string& file,
                      const std::vector<char>& message) {
  struct DeleteFile {
    void operator()(FILE* p) const {
      const auto success = std::fclose(p);
      if (success < 0) {
        const auto errno_save = errno;
        ERROR_NO_TRACE("Could not close stream: "
                       << strerror_threadsafe(errno_save) << "\n");
      }
    }
  };
  const std::unique_ptr<FILE, DeleteFile> stream(std::fopen(file.c_str(), "a"));
  if (stream == nullptr) {
    const auto errno_save = errno;
    ERROR_NO_TRACE("Could not open '" << file << "' for writing: "
                                      << strerror_threadsafe(errno_save)
                                      << "\n");
  }
  // cppcoreguidelines-pro-type-vararg: I cannot change the signature
  // of fprintf.

  // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg)
  const auto success = fprintf(stream.get(), "%s", message.data());
  if (success < 0) {
    const auto errno_save = errno;
    ERROR_NO_TRACE("Could not write '"
                   << file << "': " << strerror_threadsafe(errno_save) << "\n");
  }
}
}  // namespace

namespace Parallel {
namespace detail {
void send_message(const bool error, const std::vector<char>& message) {
  if (printer_chare_is_set and sys::my_node() != 0) {
    printer_chare[0].print(error, message);
  } else {
    do_print(error, message);
  }
}

void send_message_to_file(const std::string& file,
                          const std::vector<char>& message) {
  // Unlike in send_message, we always print through the printer
  // chare, even on node 0.  The thread-safety of the stdio functions
  // is on a per-stream basis, and all threads share the same stdout
  // and stderr, but not the stream for any random file we open.
  if (printer_chare_is_set) {
    printer_chare[0].print_to_file(file, message);
  } else {
    do_print_to_file(file, message);
  }
}
}  // namespace detail

void PrinterChare::print(const bool error, const std::vector<char>& message) {
  do_print(error, message);
}

void PrinterChare::print_to_file(const std::string& file,
                                 const std::vector<char>& message) {
  do_print_to_file(file, message);
}

void PrinterChare::register_with_charm() {
  // From the code generated by charm from the ci file.
  _registerPrintf();
}

// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
CProxy_PrinterChare printer_chare;
// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
bool printer_chare_is_set;
}  // namespace Parallel

#include "Parallel/Printf/Printf.def.h"
